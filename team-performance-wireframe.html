<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Full Alert Transparency - Critical Start</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-k5AguPzii7sqJOPIjvD2zpJ+qF6DRCcIh0b07XHtcwPa5RWPLXxF75PwQBGzb62LF8oT+yQUwpsOSJyYwcmB8g==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ['Roboto', 'Arial', 'Helvetica', 'sans-serif'],
            },
          },
        },
      };
    </script>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      :root {
        --brand-sky: #009cde;
        --brand-navy: #004c97;
        --brand-charcoal: #343741;
        --brand-plum: #702f8a;
        --brand-crimson: #ef3340;
        --brand-flame: #ff6a14;
        --brand-slate: #03162c;
      }

      body {
        font-family: 'Roboto', 'Arial', 'Helvetica', sans-serif;
        background: linear-gradient(180deg, rgba(0, 156, 222, 0.95) 0%, rgba(0, 76, 151, 0.98) 60%, rgba(3, 22, 44, 1) 100%);
        color: var(--brand-charcoal);
        min-height: 100vh;
      }

        .brand-shell {
          background: rgba(255, 255, 255, 0.98);
          border-radius: 32px;
          border: 1px solid rgba(255, 255, 255, 0.55);
          box-shadow: 0 40px 80px rgba(0, 20, 40, 0.25);
        }

        .brand-card {
          background: #ffffff;
          border: 1px solid rgba(0, 76, 151, 0.12);
          border-radius: 24px;
          box-shadow: 0 20px 50px rgba(3, 22, 44, 0.08);
        }

        .brand-gradient-panel {
          background: linear-gradient(135deg, #004c97 0%, #03162c 100%);
          color: #fdfdfd;
        }

      .brand-muted {
        color: rgba(52, 55, 65, 0.7);
      }

        .brand-small {
          color: rgba(52, 55, 65, 0.6);
          font-size: 0.75rem;
        }

        .select-base {
          width: 100%;
          border-radius: 0.75rem;
          border: 1px solid #7a8ea7;
          padding: 0.5rem 0.75rem;
          font-size: 0.875rem;
          background-color: #fff;
          color: var(--brand-charcoal);
          transition: border 0.2s ease, box-shadow 0.2s ease;
        }

        .select-base:focus {
          outline: none;
          border-color: #b34200;
          box-shadow: 0 0 0 2px rgba(3, 22, 44, 0.08), 0 0 0 4px #b34200;
        }

        .brand-toggle {
          border: 1px solid #7a8ea7;
          border-radius: 999px;
          padding: 0.25rem 0.85rem;
          font-size: 0.75rem;
          font-weight: 500;
          color: var(--brand-navy);
          transition: background 0.2s ease, color 0.2s ease;
        }

        .brand-toggle:hover {
          background: rgba(0, 156, 222, 0.12);
        }

        .brand-toggle:focus-visible {
          outline: none;
          box-shadow: 0 0 0 2px rgba(3, 22, 44, 0.08), 0 0 0 4px #b34200;
        }

        .brand-toggle--active {
          background: rgba(0, 156, 222, 0.15);
          border-color: #005ea8;
        }

      .kpi-card {
        border-radius: 20px;
        border: 1px solid rgba(0, 76, 151, 0.12);
        background: #fff;
        padding: 1.25rem;
        box-shadow: 0 10px 30px rgba(3, 22, 44, 0.08);
      }
    </style>
  </head>
  <body class="min-h-screen">
    <div id="root"></div>
    <script type="text/babel">
      const { useMemo, useState } = React;

        const BRAND = {
          sky: '#009CDE',
          navy: '#004C97',
          charcoal: '#343741',
          plum: '#702F8A',
          crimson: '#EF3340',
          flame: '#FF6A14',
          slate: '#03162C',
        };

        const DAY_LABELS = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];

        const ALERT_TYPE_OPTIONS = ['Phishing', 'Malware', 'Endpoint', 'Network', 'Insider Threat'];
        const ALERT_SOURCE_OPTIONS = ['EDR', 'Email', 'SIEM', 'Network Sensor', 'Cloud Provider'];
        const ALERT_TYPES = ['All', ...ALERT_TYPE_OPTIONS];
        const ALERT_SOURCES = ['All', ...ALERT_SOURCE_OPTIONS];

      const BrandIcon = ({ icon, label, variant = 'primary' }) => {
        const background = variant === 'secondary' ? 'rgba(255, 106, 20, 0.15)' : 'rgba(0, 156, 222, 0.12)';
        const color = variant === 'secondary' ? BRAND.flame : BRAND.navy;
        return (
          <span className="inline-flex h-9 w-9 items-center justify-center rounded-full" style={{ backgroundColor: background, color }} aria-label={label}>
            <i className={icon} aria-hidden="true"></i>
          </span>
        );
      };

        const TrendTag = ({ change, better, delta }) => {
        if (!delta) return null;
        const trendingUp = change >= 0;
        const isPositive = better === 'lower' ? !trendingUp : better === 'target' ? change >= 0 : trendingUp;
          const color = isPositive ? '#005EA8' : '#A00024';
        const iconClass = trendingUp ? 'fa-solid fa-arrow-trend-up' : 'fa-solid fa-arrow-trend-down';
        return (
          <span className="inline-flex items-center gap-1 text-xs font-medium" style={{ color }}>
            <i className={iconClass} aria-hidden="true"></i>
            {delta}
          </span>
        );
      };

      /* ------------------------------------------------------------------ */
      /* Helper utilities                                                   */
      /* ------------------------------------------------------------------ */
      const createSeededRandom = (seed) => {
        let value = seed;
        return () => ((2 ** 31 - 1) & (value = Math.imul(48271, value))) / 2 ** 31;
      };

      const range = (length, mapFn) => Array.from({ length }, (_, index) => (mapFn ? mapFn(_, index) : index));

      const formatHours = (value) => `${value.toFixed(1)} h`;

      const calculateStdDev = (values) => {
        if (!values.length) return 0;
        const mean = values.reduce((total, val) => total + val, 0) / values.length;
        const variance = values.reduce((acc, val) => acc + (val - mean) ** 2, 0) / values.length;
        return Math.sqrt(variance);
      };

      const percentChange = (current, previous) => {
        if (!Number.isFinite(current) || !Number.isFinite(previous) || previous === 0) {
          return '0';
        }
        return (((current - previous) / previous) * 100).toFixed(0);
      };

      const formatDeltaLabel = (value, suffix = '') => {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return suffix.trim();
        }
        if (numeric === 0) {
          return `0%${suffix ? ` ${suffix}` : ''}`.trim();
        }
        const formatted = `${numeric > 0 ? '+' : ''}${numeric}%`;
        return suffix ? `${formatted} ${suffix}` : formatted;
      };

        const median = (values) => {
          if (!values.length) return 0;
          const sorted = values.slice().sort((a, b) => a - b);
          const mid = Math.floor(sorted.length / 2);
          return sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
        };

        const quantile = (values, q) => {
          if (!values.length) return 0;
          const sorted = values.slice().sort((a, b) => a - b);
          const pos = (sorted.length - 1) * q;
          const base = Math.floor(pos);
          const rest = pos - base;
          return sorted[base + 1] !== undefined ? sorted[base] + rest * (sorted[base + 1] - sorted[base]) : sorted[base];
        };

        const calculateBoxStatsFor = (values) => {
          if (!values.length) {
            return { q1: 0, median: 0, q3: 0, lo: 0, hi: 0 };
          }
          return {
            q1: quantile(values, 0.25),
            median: median(values),
            q3: quantile(values, 0.75),
            lo: Math.min(...values),
            hi: Math.max(...values),
          };
        };

        const groupBy = (items, keyFn) => {
          const map = new Map();
          items.forEach((item) => {
            const key = keyFn(item);
            if (!map.has(key)) {
              map.set(key, []);
            }
            map.get(key).push(item);
          });
          return map;
        };

        const buildDayOfWeekStats = (alerts) =>
          DAY_LABELS.map((label) => {
            const subset = alerts.filter((alert) => alert.dayOfWeek === label);
            const stats = calculateBoxStatsFor(subset.map((alert) => alert.mttr));
            return { label, n: subset.length, ...stats };
          });

        const buildAnalystStats = (alerts) => {
          const grouped = groupBy(alerts, (alert) => alert.analyst);
          return Array.from(grouped.entries()).map(([name, rows]) => ({
            name,
            n: rows.length,
            ...calculateBoxStatsFor(rows.map((row) => row.mttr)),
          }));
        };

        const buildAlertTypeStats = (alerts) => {
          const grouped = groupBy(alerts, (alert) => alert.type);
          return Array.from(grouped.entries()).map(([name, rows]) => ({
            name,
            n: rows.length,
            pickup: median(rows.map((row) => row.pickup)),
            ...calculateBoxStatsFor(rows.map((row) => row.mttr)),
          }));
        };

      /* ------------------------------------------------------------------ */
      /* Synthetic dashboard data                                           */
      /* ------------------------------------------------------------------ */
        const createDashboardData = ({ weeks, seed }) => {
          const random = createSeededRandom(seed);
          const gaussian = () => {
            const u = Math.max(random(), 1e-6);
            const v = Math.max(random(), 1e-6);
            return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
          };

          const weekLabels = range(weeks, (_, index) => {
            const date = new Date();
            date.setDate(date.getDate() - (weeks - index) * 7);
            return date.toLocaleDateString(undefined, { month: 'short', day: '2-digit' });
          });

          const industryMedian = range(weeks, (_, i) => 5.4 - 0.05 * i + (random() - 0.5) * 0.1);
          const industryQ1 = industryMedian.map((value) => value - 1.1 + (random() - 0.5) * 0.05);
          const industryQ3 = industryMedian.map((value) => value + 1.1 + (random() - 0.5) * 0.05);
          const customerMedian = range(weeks, (_, i) => 5.8 - 0.12 * i + (random() - 0.5) * 0.2);
          const pickupTargets = range(weeks, (_, i) => Math.max(0.2, 1.6 - 0.07 * i + (random() - 0.5) * 0.18));
          const alertsPerWeek = range(weeks, () => 30 + Math.floor(random() * 40));

          const analystsBase = ['Avery', 'Blake', 'Casey', 'Devin', 'Emery', 'Flynn', 'Gray', 'Hayes', 'Indy', 'Jules', 'Kai', 'Logan'].map((name) => ({
            name,
          }));

          const alerts = [];
          alertsPerWeek.forEach((count, weekIndex) => {
            for (let i = 0; i < count; i += 1) {
              const analyst = analystsBase[Math.floor(random() * analystsBase.length)].name;
              const type = ALERT_TYPE_OPTIONS[Math.floor(random() * ALERT_TYPE_OPTIONS.length)];
              const source = ALERT_SOURCE_OPTIONS[Math.floor(random() * ALERT_SOURCE_OPTIONS.length)];
              const dayOfWeek = DAY_LABELS[Math.floor(random() * DAY_LABELS.length)];
              const mttr = Math.max(0.5, customerMedian[weekIndex] + gaussian() * 0.8);
              const pickup = Math.max(0.1, pickupTargets[weekIndex] + gaussian() * 0.25);
              alerts.push({
                id: `${weekIndex}-${i}`,
                weekIndex,
                weekLabel: weekLabels[weekIndex],
                analyst,
                type,
                source,
                dayOfWeek,
                mttr,
                pickup,
              });
            }
          });

          return {
            totalWeeks: weeks,
            weekLabels,
            industryMedian,
            industryQ1,
            industryQ3,
            customerMedian,
            alerts,
            analystsBase,
          };
        };

      const dashboardData = createDashboardData({ weeks: 12, seed: 1337 });

        const TIMEFRAMES = [
          { label: 'Last 4 weeks', value: 4 },
          { label: 'Last 8 weeks', value: 8 },
          { label: 'Last 12 weeks', value: 12 },
        ];
        const ANALYST_OPTIONS = ['All', ...dashboardData.analystsBase.map((analyst) => analyst.name)];

        const useTimeframeSlices = (dataset, timeframe, analystFilter, typeFilter, sourceFilter) =>
          useMemo(() => {
            const start = Math.max(0, dataset.totalWeeks - timeframe);
            const weekIndices = range(timeframe, (_, index) => start + index);
            const lbls = weekIndices.map((index) => dataset.weekLabels[index]);

            const matchesAnalyst = (alert) => analystFilter === 'All' || alert.analyst === analystFilter;
            const matchesType = (alert) => typeFilter === 'All' || alert.type === typeFilter;
            const matchesSource = (alert) => sourceFilter === 'All' || alert.source === sourceFilter;

            const filteredAlerts = dataset.alerts.filter((alert) => alert.weekIndex >= start && matchesAnalyst(alert) && matchesType(alert) && matchesSource(alert));

            const alertsByWeek = weekIndices.map((weekIndex) => filteredAlerts.filter((alert) => alert.weekIndex === weekIndex));
            const weeklyMedian = (weekAlerts, accessor) => {
              const values = weekAlerts.map(accessor).filter((value) => Number.isFinite(value));
              return values.length ? median(values) : 0;
            };

            const cust = alertsByWeek.map((weekAlerts) => weeklyMedian(weekAlerts, (alert) => alert.mttr));
            const pick = alertsByWeek.map((weekAlerts) => weeklyMedian(weekAlerts, (alert) => alert.pickup));
            const bars = alertsByWeek.map((weekAlerts) => weekAlerts.length);
            const active = alertsByWeek.map((weekAlerts) => new Set(weekAlerts.map((alert) => alert.analyst)).size);
            const apa = active.map((value, index) => (value ? +(bars[index] / value).toFixed(1) : 0));

            const slice = (array) => array.slice(start, start + timeframe);
            const ind = slice(dataset.industryMedian);
            const bandLow = slice(dataset.industryQ1);
            const bandHigh = slice(dataset.industryQ3);
            const sd = calculateStdDev(ind);
            const validWeeks = cust.filter((value) => value > 0).length;
            const withinBand = cust.filter((value, index) => value > 0 && value <= ind[index] + sd).length;
            const pctWithin1SD = validWeeks ? Math.round((withinBand / validWeeks) * 100) : 0;

            return { cust, ind, lbls, bars, pick, active, apa, pctWithin1SD, bandLow, bandHigh, filteredAlerts, weekIndices };
          }, [dataset, timeframe, analystFilter, typeFilter, sourceFilter]);

      /* ------------------------------------------------------------------ */
      /* Chart components                                                   */
      /* ------------------------------------------------------------------ */
      const LineBandChart = ({ width = 900, height = 280, xLabels, lineA, bandLow, bandHigh, lineB }) => {
        const pad = { t: 12, r: 12, b: 40, l: 40 };
        const innerW = width - pad.l - pad.r;
        const innerH = height - pad.t - pad.b;
        const allY = [...lineA, ...bandLow, ...bandHigh, ...(lineB || [])].filter(Number.isFinite);
        const yMin = Math.min(...allY) * 0.95;
        const yMax = Math.max(...allY) * 1.05;
        const x = (i) => pad.l + innerW * (i / (xLabels.length - 1 || 1));
        const y = (v) => pad.t + innerH * (1 - (v - yMin) / (yMax - yMin || 1));
        const poly = (arr) => arr.map((v, i) => `${x(i)},${y(v)}`).join(' ');
        const bandPoints = bandLow
          .map((v, i) => [x(i), y(v)])
          .concat(
            bandHigh
              .slice()
              .reverse()
              .map((v, i) => [x(bandHigh.length - 1 - i), y(v)])
          )
          .map((point) => point.join(','))
          .join(' ');
        const axisColor = '#D7DEE8';
        const gridColor = '#E5EDF7';
        return (
          <svg viewBox={`0 0 ${width} ${height}`} className="w-full h-80">
            <line x1={pad.l} y1={height - pad.b} x2={width - pad.r} y2={height - pad.b} stroke={axisColor} />
            <line x1={pad.l} y1={pad.t} x2={pad.l} y2={height - pad.b} stroke={axisColor} />
            {[0, 0.25, 0.5, 0.75, 1].map((t, index) => {
              const yy = pad.t + innerH * (1 - t);
              const val = yMin + (yMax - yMin) * t;
              return (
                <g key={index}>
                  <line x1={pad.l} x2={width - pad.r} y1={yy} y2={yy} stroke={gridColor} />
                  <text x={10} y={yy + 4} className="text-[10px]" style={{ fill: '#5C6170' }}>
                    {val.toFixed(1)}
                  </text>
                </g>
              );
            })}
            <polygon points={bandPoints} fill="rgba(0, 156, 222, 0.12)" />
            {lineB && <polyline fill="none" strokeDasharray="4 4" strokeWidth="2" stroke={BRAND.sky} points={poly(lineB)} />}
            <polyline fill="none" strokeWidth="2.4" stroke={BRAND.navy} points={poly(lineA)} />
            {xLabels.map((label, index) => (
              <text key={index} x={x(index)} y={height - 10} className="text-[10px]" style={{ fill: '#5C6170' }} textAnchor="middle">
                {label}
              </text>
            ))}
          </svg>
        );
      };

      const BoxPlotChart = ({ data, width = 900, height = 280 }) => {
        const pad = { t: 12, r: 12, b: 50, l: 40 };
        const innerW = width - pad.l - pad.r;
        const innerH = height - pad.t - pad.b;
        const yMin = 0;
        const yMax = Math.max(...data.map((d) => d.q3)) + 5;
        const xStep = innerW / data.length;
        const x = (i) => pad.l + xStep * (i + 0.5);
        const y = (v) => pad.t + innerH * (1 - (v - yMin) / (yMax - yMin || 1));
        const axisColor = '#D7DEE8';
        const gridColor = '#E5EDF7';
        return (
          <svg viewBox={`0 0 ${width} ${height}`} className="w-full h-80">
            <line x1={pad.l} y1={height - pad.b} x2={width - pad.r} y2={height - pad.b} stroke={axisColor} />
            <line x1={pad.l} y1={pad.t} x2={pad.l} y2={height - pad.b} stroke={axisColor} />
            {[0, 0.25, 0.5, 0.75, 1].map((t, index) => {
              const yy = pad.t + innerH * (1 - t);
              const val = yMin + (yMax - yMin) * t;
              return (
                <g key={index}>
                  <line x1={pad.l} x2={width - pad.r} y1={yy} y2={yy} stroke={gridColor} />
                  <text x={10} y={yy + 4} className="text-[10px]" style={{ fill: '#5C6170' }}>
                    {val.toFixed(1)}
                  </text>
                </g>
              );
            })}
            {data.map((d, index) => {
              const cx = x(index);
              const boxW = Math.min(50, xStep * 0.6);
              const yQ1 = y(d.q1);
              const yQ3 = y(d.q3);
              const yMed = y(d.median);
              const yLo = y(d.lo);
              const yHi = y(d.hi);
              return (
                <g key={index}>
                  <line x1={cx} x2={cx} y1={yQ3} y2={yHi} stroke={BRAND.sky} />
                  <line x1={cx - 10} x2={cx + 10} y1={yHi} y2={yHi} stroke={BRAND.sky} />
                  <line x1={cx} x2={cx} y1={yQ1} y2={yLo} stroke={BRAND.sky} />
                  <line x1={cx - 10} x2={cx + 10} y1={yLo} y2={yLo} stroke={BRAND.sky} />
                  <rect x={cx - boxW / 2} y={yQ3} width={boxW} height={yQ1 - yQ3} fill="rgba(0, 76, 151, 0.08)" stroke={BRAND.navy} />
                  <line x1={cx - boxW / 2} x2={cx + boxW / 2} y1={yMed} y2={yMed} stroke={BRAND.navy} />
                  <text x={cx} y={height - 10} className="text-[10px]" style={{ fill: '#5C6170' }} textAnchor="middle">
                    {d.label}
                  </text>
                </g>
              );
            })}
          </svg>
        );
      };

      const HorizontalIQRBars = ({ rows, width = 900, height = 320 }) => {
        const pad = { t: 12, r: 12, b: 40, l: 120 };
        const innerW = width - pad.l - pad.r;
        const innerH = height - pad.t - pad.b;
        const yStep = innerH / rows.length;
        const xMin = 0;
        const xMax = Math.max(...rows.map((r) => r.q3)) + 3;
        const x = (v) => pad.l + (innerW * v) / (xMax - xMin || 1);
        const y = (i) => pad.t + yStep * (i + 0.5);
        const axisColor = '#D7DEE8';
        return (
          <svg viewBox={`0 0 ${width} ${height}`} className="w-full h-80">
            <line x1={pad.l} y1={height - pad.b} x2={width - pad.r} y2={height - pad.b} stroke={axisColor} />
            <line x1={pad.l} y1={pad.t} x2={pad.l} y2={height - pad.b} stroke={axisColor} />
            {rows.map((row, index) => {
              const cy = y(index);
              return (
                <g key={row.name}>
                  <rect x={x(row.q1)} y={cy - 8} width={Math.max(2, x(row.q3) - x(row.q1))} height="16" fill="rgba(0, 156, 222, 0.12)" stroke={BRAND.navy} />
                  <line x1={x(row.q1)} x2={x(row.lo)} y1={cy} y2={cy} stroke={BRAND.sky} />
                  <line x1={x(row.q3)} x2={x(row.hi)} y1={cy} y2={cy} stroke={BRAND.sky} />
                  <line x1={x(row.median)} x2={x(row.median)} y1={cy - 10} y2={cy + 10} stroke={BRAND.navy} />
                  <text x={width - pad.r} y={cy + 3} className="text-[10px]" style={{ fill: '#5C6170' }} textAnchor="end">
                    {row.n} alerts
                  </text>
                  <text x={pad.l - 8} y={cy + 3} className="text-[11px]" style={{ fill: '#343741' }} textAnchor="end">
                    {row.name}
                  </text>
                </g>
              );
            })}
            <line x1={x(5.2)} x2={x(5.2)} y1={pad.t} y2={height - pad.b} stroke={BRAND.plum} strokeDasharray="4 3" />
            <text x={x(5.2) + 4} y={pad.t + 12} className="text-[10px]" style={{ fill: '#5C6170' }}>
              Team median
            </text>
          </svg>
        );
      };

        const SlowTypesChart = ({ rows, width = 900, height = 360 }) => {
          if (!rows.length) {
            return <p className="text-xs brand-muted">No alert types match the current filters.</p>;
          }
        const pad = { t: 12, r: 12, b: 40, l: 220 };
        const innerW = width - pad.l - pad.r;
        const innerH = height - pad.t - pad.b;
        const yStep = innerH / rows.length;
        const xMax = Math.max(...rows.map((r) => r.pickup + r.median)) * 1.1 || 1;
        const x = (v) => pad.l + (innerW * v) / xMax;
        const y = (i) => pad.t + yStep * (i + 0.5);
        const axisColor = '#D7DEE8';
        const gridColor = '#E5EDF7';
        return (
          <svg viewBox={`0 0 ${width} ${height}`} className="w-full h-96">
            <line x1={pad.l} y1={height - pad.b} x2={width - pad.r} y2={height - pad.b} stroke={axisColor} />
            {[0, 0.25, 0.5, 0.75, 1].map((t, index) => {
              const xv = xMax * t;
              const xx = x(xv);
              return (
                <g key={index}>
                  <line x1={xx} x2={xx} y1={pad.t} y2={height - pad.b} stroke={gridColor} />
                  <text x={xx} y={height - 10} className="text-[10px]" style={{ fill: '#5C6170' }} textAnchor="middle">
                    {xv.toFixed(1)}
                  </text>
                </g>
              );
            })}
            {rows.map((row, index) => {
              const cy = y(index);
              const total = row.pickup + row.median;
              return (
                <g key={row.name}>
                  <rect x={x(0)} y={cy - 8} width={Math.max(2, Math.abs(x(row.pickup) - x(0)))} height="16" fill="rgba(0, 156, 222, 0.25)" />
                  <rect x={x(row.pickup)} y={cy - 8} width={Math.max(2, Math.abs(x(total) - x(row.pickup)))} height="16" fill={BRAND.navy} />
                  <text x={pad.l - 10} y={cy + 3} className="text-[11px]" style={{ fill: '#343741' }} textAnchor="end">
                    {row.name}
                  </text>
                  <text x={x(total) + 6} y={cy + 3} className="text-[10px]" style={{ fill: '#5C6170' }}>
                    {formatHours(row.pickup)} + {formatHours(row.median)} = {formatHours(total)} · {row.n} alerts
                  </text>
                </g>
              );
            })}
            <g transform={`translate(${width - 280},${pad.t + 6})`}>
              <rect x="0" y="-10" width="270" height="34" fill="#ffffff" opacity="0.85" />
              <rect x="10" y="-2" width="20" height="8" fill="rgba(0, 156, 222, 0.35)" />
              <text x="36" y="5" className="text-[10px]" style={{ fill: '#343741' }}>
                Median time to analyst pickup
              </text>
              <rect x="10" y="14" width="20" height="8" fill={BRAND.navy} />
              <text x="36" y="21" className="text-[10px]" style={{ fill: '#343741' }}>
                MTTR (resolution)
              </text>
            </g>
          </svg>
        );
      };

      const ComboBarDualLine = ({ bars, lineA, lineB, labels, legendA = 'MTTR (resolve)', legendB = 'Median time to analyst pickup', width = 900, height = 300 }) => {
        const pad = { t: 12, r: 12, b: 40, l: 40 };
        const innerW = width - pad.l - pad.r;
        const innerH = height - pad.t - pad.b;
        const xStep = innerW / labels.length;
        const yMax = Math.max(...bars) * 1.2;
        const yMin = 0;
        const yBar = (v) => pad.t + innerH * (1 - (v - yMin) / (yMax - yMin || 1));
        const allLine = [...lineA, ...(lineB || [])].filter(Number.isFinite);
        const lMin = Math.min(...allLine) * 0.95;
        const lMax = Math.max(...allLine) * 1.05;
        const yLine = (val) => pad.t + innerH * (1 - (val - lMin) / (lMax - lMin || 1));
        const x = (i) => pad.l + xStep * (i + 0.5);
        const poly = (arr) => arr.map((v, i) => `${x(i)},${yLine(v)}`).join(' ');
        const axisColor = '#D7DEE8';
        const gridColor = '#E5EDF7';
        return (
          <svg viewBox={`0 0 ${width} ${height}`} className="w-full h-80">
            <line x1={pad.l} y1={height - pad.b} x2={width - pad.r} y2={height - pad.b} stroke={axisColor} />
            <line x1={pad.l} y1={pad.t} x2={pad.l} y2={height - pad.b} stroke={axisColor} />
            {labels.map((label, index) => {
              const bx = x(index) - Math.min(24, xStep * 0.35);
              const bw = Math.min(48, xStep * 0.7);
              return (
                <g key={label}>
                  <rect x={bx} y={yBar(bars[index])} width={bw} height={height - pad.b - yBar(bars[index])} fill="rgba(0, 76, 151, 0.08)" stroke={BRAND.navy} />
                  <text x={x(index)} y={height - 10} textAnchor="middle" className="text-[10px]" style={{ fill: '#5C6170' }}>
                    {label}
                  </text>
                </g>
              );
            })}
            <polyline fill="none" stroke={BRAND.navy} strokeWidth="2" points={poly(lineA)} />
            {lineB && <polyline fill="none" stroke={BRAND.sky} strokeDasharray="5 4" strokeWidth="2" points={poly(lineB)} />}
            <g transform={`translate(${width - 260},${pad.t + 6})`}>
              <rect x="0" y="-10" width="250" height="38" fill="#ffffff" opacity="0.85" />
              <line x1="10" x2="38" y1="0" y2="0" stroke={BRAND.navy} strokeWidth="2" />
              <text x="44" y="3" className="text-[10px]" style={{ fill: '#343741' }}>
                {legendA}
              </text>
              <line x1="10" x2="38" y1="16" y2="16" stroke={BRAND.sky} strokeDasharray="5 4" strokeWidth="2" />
              <text x="44" y="19" className="text-[10px]" style={{ fill: '#343741' }}>
                {legendB}
              </text>
            </g>
          </svg>
        );
      };

      /* ------------------------------------------------------------------ */
      /* UI building blocks                                                 */
      /* ------------------------------------------------------------------ */
      const FilterBar = ({ timeframe, setTimeframe, analyst, setAnalyst, type, setType, source, setSource }) => (
        <div className="brand-card p-5 space-y-4">
          <div className="flex flex-wrap items-center justify-between gap-3">
            <div className="flex items-center gap-3 text-sm font-semibold" style={{ color: BRAND.navy }}>
              <BrandIcon icon="fa-solid fa-sliders" label="Filter" />
              Scenario filters
            </div>
            <p className="text-xs brand-muted">Test time frames, analyst mixes, alert types, and sources before you brief leadership.</p>
          </div>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-3">
            <div>
              <label className="block text-xs font-medium brand-muted mb-1">Time frame</label>
              <select className="select-base" value={timeframe} onChange={(event) => setTimeframe(Number(event.target.value))}>
                {TIMEFRAMES.map((tf) => (
                  <option key={tf.value} value={tf.value}>
                    {tf.label}
                  </option>
                ))}
              </select>
            </div>
            <div>
              <label className="block text-xs font-medium brand-muted mb-1">Analyst name</label>
              <select className="select-base" value={analyst} onChange={(event) => setAnalyst(event.target.value)}>
                {ANALYST_OPTIONS.map((option) => (
                  <option key={option} value={option}>
                    {option}
                  </option>
                ))}
              </select>
            </div>
            <div>
              <label className="block text-xs font-medium brand-muted mb-1">Alert type</label>
              <select className="select-base" value={type} onChange={(event) => setType(event.target.value)}>
                {ALERT_TYPES.map((option) => (
                  <option key={option} value={option}>
                    {option}
                  </option>
                ))}
              </select>
            </div>
            <div>
              <label className="block text-xs font-medium brand-muted mb-1">Alert source</label>
              <select className="select-base" value={source} onChange={(event) => setSource(event.target.value)}>
                {ALERT_SOURCES.map((option) => (
                  <option key={option} value={option}>
                    {option}
                  </option>
                ))}
              </select>
            </div>
          </div>
            <p className="text-xs brand-muted">These filters scope every KPI, chart, and case drill-down before data renders.</p>
        </div>
      );

      const Card = ({ title, eyebrow, right, children }) => (
        <div className="brand-card p-4 md:p-6 flex flex-col gap-3">
          <div className="flex items-start justify-between gap-3">
            <div>
              {eyebrow && (
                <p className="text-[10px] font-semibold tracking-[0.3em]" style={{ color: BRAND.sky }}>
                  {eyebrow}
                </p>
              )}
              <h3 className="text-lg font-semibold" style={{ color: BRAND.charcoal }}>
                {title}
              </h3>
            </div>
            {right}
          </div>
          <div className="flex-1">{children}</div>
        </div>
      );

      const ToggleButton = ({ active, onClick, children }) => (
        <button className={`brand-toggle ${active ? 'brand-toggle--active' : ''}`} onClick={onClick}>
          {children}
        </button>
      );

        const DowChartContent = ({ data }) => {
          const [mode, setMode] = useState('box');
          const hasData = data.some((entry) => entry.n > 0);

        const SwarmPlot = ({ data: swarmData, width = 900, height = 280 }) => {
          const pad = { t: 12, r: 12, b: 50, l: 50 };
          const innerW = width - pad.l - pad.r;
          const innerH = height - pad.t - pad.b;
          const yMaxT = Math.max(...swarmData.map((d) => d.hi));
          const yMax = Math.max(5, Math.ceil(yMaxT / 5) * 5);
          const xStep = innerW / swarmData.length;
          const x = (i) => pad.l + xStep * (i + 0.5);
          const y = (v) => pad.t + innerH * (1 - v / (yMax || 1));
          const points = [];
          swarmData.forEach((d, i) => {
            const iqr = Math.max(0.1, d.q3 - d.q1);
            const sd = iqr / 1.35;
            const count = Math.min(d.n, 200);
            for (let j = 0; j < count; j += 1) {
              const u = Math.random();
              let v;
              if (u < 0.7) {
                const z = Math.sqrt(-2 * Math.log(Math.max(1e-6, Math.random()))) * Math.cos(2 * Math.PI * Math.random());
                v = d.median + z * sd;
              } else if (u < 0.85) {
                v = d.lo + Math.random() * Math.max(0, d.q1 - d.lo);
              } else {
                v = d.q3 + Math.random() * Math.max(0, d.hi - d.q3);
              }
              v = Math.min(d.hi, Math.max(d.lo, v));
              const jitter = (Math.random() - 0.5) * 12;
              points.push({ x: x(i) + jitter, y: y(v) });
            }
          });
          const yTicks = Array.from({ length: Math.floor(yMax / 5) + 1 }, (_, k) => k * 5);
          const axisColor = '#D7DEE8';
          const gridColor = '#E5EDF7';
          return (
            <svg viewBox={`0 0 ${width} ${height}`} className="w-full h-80">
              <line x1={pad.l} y1={height - pad.b} x2={width - pad.r} y2={height - pad.b} stroke={axisColor} />
              <line x1={pad.l} y1={pad.t} x2={pad.l} y2={height - pad.b} stroke={axisColor} />
              {yTicks.map((tick) => {
                const yy = y(tick);
                return (
                  <g key={tick}>
                    <line x1={pad.l} x2={width - pad.r} y1={yy} y2={yy} stroke={gridColor} />
                    <text x={pad.l - 8} y={yy + 3} className="text-[10px]" style={{ fill: '#5C6170' }} textAnchor="end">
                      {tick}
                    </text>
                  </g>
                );
              })}
              <text x={12} y={pad.t + innerH / 2} transform={`rotate(-90 12 ${pad.t + innerH / 2})`} className="text-[10px]" style={{ fill: '#5C6170' }}>
                Hours
              </text>
              {points.map((point, idx) => (
                <circle key={idx} cx={point.x} cy={point.y} r="2" fill={BRAND.navy} opacity="0.55" />
              ))}
              {swarmData.map((d, i) => (
                <text key={d.label} x={x(i)} y={height - 10} className="text-[10px]" style={{ fill: '#5C6170' }} textAnchor="middle">
                  {d.label}
                </text>
              ))}
            </svg>
          );
        };

          return (
            <div>
              {hasData ? (
                <>
                  <ToggleButton active={mode === 'box'} onClick={() => setMode(mode === 'box' ? 'swarm' : 'box')}>
                    {mode === 'box' ? 'Show swarm plot' : 'Show box & whiskers'}
                  </ToggleButton>
                  {mode === 'box' ? <BoxPlotChart data={data} /> : <SwarmPlot data={data} />}
                  <ul className="text-xs brand-muted mt-3 list-disc list-inside">
                    <li>Spot the days where pickup, workload, and MTTR swings widen before backlog builds.</li>
                    <li>Pair higher-spread days with automation or surge analysts to keep promises to the business.</li>
                    <li>Weekends trending hot? Shift playbooks or escalation windows, not just staffing numbers.</li>
                  </ul>
                </>
              ) : (
                <p className="text-xs brand-muted">No alerts match the current filters for this view.</p>
              )}
            </div>
          );
      };

        const AnalystBreakdownContent = ({ analysts }) => {
          const [mode, setMode] = useState('mttr');
          const rowsCounts = analysts.map((analyst) => ({ name: analyst.name, value: analyst.n }));
          const hasData = analysts.length > 0 && analysts.some((analyst) => analyst.n > 0);
        const countsChart = () => {
          const pad = { t: 12, r: 12, b: 40, l: 120 };
          const width = 900;
          const height = 320;
          const innerW = width - pad.l - pad.r;
          const innerH = height - pad.t - pad.b;
          const yStep = innerH / rowsCounts.length;
          const max = Math.max(...rowsCounts.map((row) => row.value));
          return (
            <svg viewBox="0 0 900 320" className="w-full h-80">
              {rowsCounts.map((row, index) => {
                const y = pad.t + yStep * (index + 0.5);
                const xWidth = (row.value / max) * innerW;
                return (
                  <g key={row.name}>
                    <rect x={pad.l} y={y - 8} width={xWidth} height="16" fill="rgba(0, 76, 151, 0.08)" stroke={BRAND.navy} />
                    <text x={pad.l - 8} y={y + 3} textAnchor="end" className="text-[11px]" style={{ fill: '#343741' }}>
                      {row.name}
                    </text>
                    <text x={pad.l + xWidth + 6} y={y + 3} className="text-[10px]" style={{ fill: '#5C6170' }}>
                      {row.value} alerts
                    </text>
                  </g>
                );
              })}
            </svg>
          );
        };

          return (
            <div>
              {hasData ? (
                <>
                  <ToggleButton active={mode === 'mttr'} onClick={() => setMode(mode === 'mttr' ? 'counts' : 'mttr')}>
                    {mode === 'mttr' ? 'Show alerts per analyst' : 'Show MTTR per analyst'}
                  </ToggleButton>
                  {mode === 'mttr' ? <HorizontalIQRBars rows={analysts} /> : countsChart()}
                  <ul className="text-xs brand-muted mt-3 list-disc list-inside">
                    <li>Contrast wide MTTR spreads with workload to decide where coaching or relief matters most.</li>
                    <li>Pair faster analysts with slower peers for priority alert types to shrink the entire band.</li>
                    <li>Hold the story to people, process, and data enrichment so the conversation stays human.</li>
                  </ul>
                </>
              ) : (
                <p className="text-xs brand-muted">No analyst data matches the current filters.</p>
              )}
            </div>
          );
      };

      /* ------------------------------------------------------------------ */
      /* Main dashboard                                                     */
      /* ------------------------------------------------------------------ */
      function DashboardApp() {
        const [timeframe, setTimeframe] = useState(TIMEFRAMES[TIMEFRAMES.length - 1].value);
        const [analyst, setAnalyst] = useState('All');
        const [type, setType] = useState('All');
        const [source, setSource] = useState('All');

          const { cust, ind, lbls, pick, apa, pctWithin1SD, bandLow, bandHigh, filteredAlerts } = useTimeframeSlices(dashboardData, timeframe, analyst, type, source);

        const latestCust = cust[cust.length - 1];
        const latestInd = ind[ind.length - 1];
        const latestPick = pick[pick.length - 1];
        const latestApa = apa[apa.length - 1];

        const baselineCust = cust[Math.max(0, cust.length - 5)] ?? latestCust;
        const baselinePick = pick[Math.max(0, pick.length - 5)] ?? latestPick;
        const baselineApa = apa[Math.max(0, apa.length - 2)] ?? latestApa;

        const kpis = [
          {
            label: 'Weekly MTTR (median)',
            value: formatHours(latestCust),
            delta: formatDeltaLabel(percentChange(latestCust, baselineCust), 'vs last 4 weeks'),
            change: latestCust - baselineCust,
            better: 'lower',
            sub: `Sector median: ${formatHours(latestInd)}`,
            icon: 'fa-regular fa-clock',
          },
            {
              label: 'Weeks inside peer performance band',
              value: `${pctWithin1SD}%`,
              delta: 'Target ≥ 85%',
              change: pctWithin1SD - 85,
              better: 'target',
              sub: 'Share of weeks where MTTR stays within the sector median plus one standard deviation.',
              icon: 'fa-solid fa-bullseye',
            },
          {
            label: 'Median time to analyst pickup',
            value: formatHours(latestPick),
            delta: formatDeltaLabel(percentChange(latestPick, baselinePick), 'vs last 4 weeks'),
            change: latestPick - baselinePick,
            better: 'lower',
            sub: 'Clock starts when Critical Start assigns the alert to your queue.',
            icon: 'fa-regular fa-hand-pointer',
          },
          {
            label: 'Alerts per analyst (index)',
            value: latestApa.toFixed(1),
            delta: formatDeltaLabel(percentChange(latestApa, baselineApa), 'vs prior week'),
            change: latestApa - baselineApa,
            better: 'lower',
            sub: 'Higher values mean more pressure on every active analyst.',
            icon: 'fa-solid fa-users-gear',
          },
        ];

          const dayOfWeekStats = useMemo(() => buildDayOfWeekStats(filteredAlerts), [filteredAlerts]);
          const analystStats = useMemo(() => {
            const stats = buildAnalystStats(filteredAlerts);
            return analyst === 'All' ? stats : stats.filter((entry) => entry.name === analyst);
          }, [filteredAlerts, analyst]);
          const slowestAlertTypes = useMemo(() => {
            const stats = buildAlertTypeStats(filteredAlerts);
            return stats.sort((a, b) => b.pickup + b.median - (a.pickup + a.median)).slice(0, 10);
          }, [filteredAlerts]);

        return (
          <div className="min-h-screen py-10 px-4 sm:px-6 lg:px-8">
            <div className="max-w-7xl mx-auto brand-shell p-6 sm:p-8 space-y-6">
                <header className="space-y-3">
                  <p className="text-xs font-semibold tracking-[0.3em]" style={{ color: BRAND.sky }}>
                    Critical Start MDR Operations
                  </p>
                  <h1 className="text-3xl font-bold tracking-tight" style={{ color: BRAND.charcoal }}>
                    Your Team Performance dashboard.
                  </h1>
                  <p className="text-sm brand-muted">Show how your analysts pick up, investigate, and resolve every validated alert—then coach the next action with confidence.</p>
                  <p className="text-sm brand-muted">
                    Once our U.S.-based, 24/7/365 SOC hands you a validated alert, this view shows how your team responds against sector peers. Tie every insight to staffing, workflow, and runway so follow-up
                    plans feel confident, human, and actionable.
                  </p>
                  <p className="text-xs brand-muted">
                    Every metric stays benchmarked against sector medians, quartiles, and ±1σ bands while reinforcing Critical Start&rsquo;s 90% analyst retention and SOC transparency promises.
                  </p>
                </header>

              <section className="brand-card brand-gradient-panel p-5 sm:p-6 space-y-3">
                <h2 className="text-lg font-semibold text-white">How to work this dashboard</h2>
                <p className="text-sm text-white/90">Use it as your coaching brief: describe what happened, why it matters, and what you&rsquo;ll adjust.</p>
                <ul className="list-disc pl-5 text-sm text-white/85 space-y-1">
                  <li>Anchor the story in MTTR versus the shaded peer band before requesting new coverage or tooling.</li>
                  <li>Triangulate pickup, analyst variance, and alert complexity to decide if the queue, investigation, or response needs help first.</li>
                  <li>Call out trending weeks, not isolated spikes, so leadership sees a clear narrative, next steps, and owners.</li>
                </ul>
              </section>

              <FilterBar timeframe={timeframe} setTimeframe={setTimeframe} analyst={analyst} setAnalyst={setAnalyst} type={type} setType={setType} source={source} setSource={setSource} />

              <section className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
                {kpis.map((kpi) => (
                  <div key={kpi.label} className="kpi-card space-y-3">
                    <div className="flex items-center justify-between">
                      <span className="text-xs font-medium brand-muted">{kpi.label}</span>
                      <BrandIcon icon={kpi.icon} label={kpi.label} />
                    </div>
                    <div className="flex items-baseline gap-2">
                      <span className="text-2xl font-semibold" style={{ color: BRAND.charcoal }}>
                        {kpi.value}
                      </span>
                      <TrendTag change={kpi.change} better={kpi.better} delta={kpi.delta} />
                    </div>
                    <p className="text-xs brand-muted">{kpi.sub}</p>
                  </div>
                ))}
              </section>

              <section className="flex flex-col gap-6">
                <Card title="Stopping threats today, preparing for tomorrow" eyebrow="MTTR VS SECTOR" right={<BrandIcon icon="fa-solid fa-chart-line" label="Line chart" variant="secondary" />}>
                  <LineBandChart xLabels={lbls} lineA={cust} lineB={ind} bandLow={bandLow} bandHigh={bandHigh} />
                    <ul className="text-xs brand-muted mt-3 list-disc list-inside">
                      <li>Solid line = your weekly MTTR. Keep it inside the shaded sector Q1–Q3 band and ±1σ guardrails to stay confident in your coverage.</li>
                      <li>Dashed line = sector median. Multiple weeks above it signal workflow or staffing pivots to discuss.</li>
                      <li>Highlight spike weeks, then drill into the filters to show which alert types or handoffs stalled.</li>
                    </ul>
                </Card>

                  <Card title="Secure every moment with always-on vigilance" eyebrow="DAY-OF-WEEK STORY" right={<BrandIcon icon="fa-regular fa-chart-bar" label="Bar chart" variant="secondary" />}>
                    <DowChartContent data={dayOfWeekStats} />
                  </Card>

                  <Card title="Human intuition meets cutting-edge tech" eyebrow="ANALYST BREAKDOWN" right={<BrandIcon icon="fa-solid fa-people-group" label="Analyst" variant="secondary" />}>
                    <AnalystBreakdownContent analysts={analystStats} />
                  </Card>

                <Card title="Less backlog, more breathing room" eyebrow="WORKLOAD + MTTR" right={<BrandIcon icon="fa-solid fa-wave-square" label="Activity" variant="secondary" />}>
                  <ComboBarDualLine bars={apa} lineA={cust} lineB={pick} labels={lbls} />
                  <ul className="text-xs brand-muted mt-3 list-disc list-inside">
                    <li>Bars show workload per analyst; the solid line shows MTTR, and the dashed line tracks pickup speed.</li>
                    <li>If MTTR climbs while pickup stays flat, backlog lives inside investigation, not queue acceptance.</li>
                    <li>When bars jump by ~15% week over week, lock in surge coverage, smarter triage, or automation.</li>
                  </ul>
                </Card>

                  <Card title="Custom responses that turn complexity into clarity" eyebrow="SLOWEST ALERT TYPES">
                    <SlowTypesChart rows={slowestAlertTypes} />
                  <ul className="text-xs brand-muted mt-3 list-disc list-inside">
                    <li>Stacked bars combine pickup (light) and MTTR (dark) for the ten slowest alert types in your queue.</li>
                    <li>Use this view to justify new playbooks, enrichment feeds, or vendor escalations.</li>
                    <li>Action: pair a fast analyst with a slower peer on the top rows for the next sprint, and narrate the results back here.</li>
                  </ul>
                </Card>
              </section>

              <footer className="text-xs brand-muted space-y-1">
                <p>Implementation tip: calculate weekly medians (excluding weekends if agreed), render the shaded peer band from sector Q1–Q3, and keep data deterministic for demos.</p>
                <p>Need to share this view? Export the story with the approved Critical Start boilerplate so every audience hears the same promise.</p>
              </footer>
            </div>
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById('root')).render(<DashboardApp />);
    </script>
  </body>
</html>
